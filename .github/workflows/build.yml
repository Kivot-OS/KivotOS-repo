name: Build Packages

on:
  push:
    branches: [ "main" ]
    paths:
      - "packages/**.toml"
      - "packages.lock"
      - "scripts/**"
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.x'
      - name: Generate Matrix
        id: set-matrix
        run: |
          pip install toml requests
          MATRIX=$(python scripts/manager.py matrix)
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  build:
    needs: matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.matrix.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Install Build Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential git jq curl

      - name: Install Package Build Dependencies
        if: matrix.depends && matrix.depends.build
        run: |
          echo "Installing build dependencies..."
          DEPS=$(echo '${{ toJson(matrix.depends.build) }}' | jq -r '.[]' | tr '\n' ' ')
          if [ -n "$DEPS" ]; then
            echo "Installing: $DEPS"
            sudo apt-get install -y $DEPS
          fi

      - name: Setup Rust toolchain
        if: matrix.type == 'cargo' || matrix.type == 'make'
        uses: dtolnay/rust-toolchain@stable
          
      - name: Build Package
        env:
          APP_VERSION: ${{ matrix.version }}
          POST_BUILD: ${{ matrix.post_build }}
        run: |
          # Create build directory
          mkdir -p build
          
          # Run build command
          echo "Building ${{ matrix.name }} version ${{ matrix.version }}"...
          
          # Convert repo shorthand to full URL
          REPO_URL="${{ matrix.repo }}"
          if [[ "$REPO_URL" == github:* ]]; then
             REPO_URL="https://github.com/${REPO_URL#github:}"
          elif [[ "$REPO_URL" == codeberg:* ]]; then
             REPO_URL="https://codeberg.org/${REPO_URL#codeberg:}"
          fi
          
          if [[ "${{ matrix.type }}" == "custom" ]]; then
             git clone "$REPO_URL" src
             cd src
             if [[ "${{ matrix.version }}" != "latest" ]]; then
               git checkout ${{ matrix.version }}
             fi
             ${{ matrix.build_cmd }}
             # Run post-build if defined (e.g., extract from zip)
             if [ -n "$POST_BUILD" ]; then
               echo "Running post-build command..."
               eval "$POST_BUILD"
             fi
             cd ..
          elif [[ "${{ matrix.type }}" == "cargo" ]]; then
            git clone "$REPO_URL" src
            cd src
            if [[ "${{ matrix.version }}" != "latest" ]]; then
              git checkout ${{ matrix.version }}
            fi
            # Try cargo-deb first (if project supports it), fallback to cargo build
            if cargo install cargo-deb 2>/dev/null && cargo deb 2>/dev/null; then
              echo "Successfully built with cargo-deb"
            else
              echo "Falling back to cargo build"
              cargo build --release
            fi
            cd ..
          elif [[ "${{ matrix.type }}" == "make" ]]; then
             git clone "$REPO_URL" src
             cd src
             if [[ "${{ matrix.version }}" != "latest" ]]; then
               git checkout ${{ matrix.version }}
             fi
             # Ensure rustup cargo is in PATH
             source $HOME/.cargo/env 2>/dev/null || true
             export PATH="$HOME/.cargo/bin:$PATH"
             ${{ matrix.build_cmd }}
             cd ..
          elif [[ "${{ matrix.type }}" == "ninja" ]]; then
             git clone "$REPO_URL" src
             cd src
             if [[ "${{ matrix.version }}" != "latest" ]]; then
               git checkout ${{ matrix.version }}
             fi
             # Meson/Ninja build
             meson setup build --prefix=/usr --buildtype=release
             ninja -C build
             cd ..
          fi
          
      - name: Package .deb
        if: matrix.type != 'custom'
        run: |
          PKG_NAME="${{ matrix.name }}"
          VERSION="${{ matrix.version }}"
          # Remove 'v' from version for debian compliance
          DEB_VER="${VERSION#v}"
          ARCH="amd64"
          
          # Create debian structure
          mkdir -p pkg/DEBIAN
          
          # Install files based on JSON mapping
          # We need to parse the JSON object 'install'
          # Since it's passed as a string in matrix, we can access it via context or parse it
          
          # Helper function to install files
          # Note: Github Actions matrix objects are available as JSON
          
          echo '${{ toJson(matrix.install) }}' > install_map.json
          
          jq -r 'to_entries[] | "\(.key) \(.value)"' install_map.json | while read -r SRC DST;
          do
             # Resolve SRC relative to build context
             # If type is cargo/make, SRC might be in src/
             
             if [[ -f "src/$SRC" ]]; then
                REAL_SRC="src/$SRC"
             elif [[ -f "$SRC" ]]; then
                REAL_SRC="$SRC"
             else
                echo "Warning: Source file $SRC not found"
                continue
             fi
             
             DEST_DIR="pkg$(dirname "$DST")"
             mkdir -p "$DEST_DIR"
             cp "$REAL_SRC" "pkg$DST"
             # Set permissions based on file type
             if [[ "$DST" == */bin/* ]] || [[ "$DST" == *completions* ]]; then
                chmod 755 "pkg$DST"
             else
                chmod 644 "pkg$DST"
             fi
          done
          
          # Parse control from matrix
          MAINTAINER=$(echo '${{ toJson(matrix.control) }}' | jq -r '.maintainer // "KivotOS <kivotos@example.com>"')
          SECTION=$(echo '${{ toJson(matrix.control) }}' | jq -r '.section // "utils"')
          PRIORITY=$(echo '${{ toJson(matrix.control) }}' | jq -r '.priority // "optional"')
          HOMEPAGE=$(echo '${{ toJson(matrix.control) }}' | jq -r '.homepage // ""')
          RUNTIME_DEPS=$(echo '${{ toJson(matrix.depends) }}' | jq -r '.runtime | join(", ") // ""')
          
          # Create control file
          # Build control file content
          CONTROL="Package: $PKG_NAME\n"
          CONTROL+="Version: $DEB_VER\n"
          CONTROL+="Architecture: $ARCH\n"
          CONTROL+="Maintainer: $MAINTAINER\n"
          CONTROL+="Description: ${{ matrix.description }}\n"
          CONTROL+="Priority: $PRIORITY\n"
          CONTROL+="Section: $SECTION\n"
          if [ -n "$HOMEPAGE" ]; then
            CONTROL+="Homepage: $HOMEPAGE\n"
          fi
          if [ -n "$RUNTIME_DEPS" ]; then
            CONTROL+="Depends: $RUNTIME_DEPS\n"
          fi
          echo -e "$CONTROL" > pkg/DEBIAN/control
          
          # Build .deb
          mkdir -p dist
          dpkg-deb --build pkg "dist/${PKG_NAME}_${DEB_VER}_${ARCH}.deb"
          
      - name: Find custom .deb
        if: matrix.type == 'custom'
        run: |
          # Custom build script or cargo-deb should create .deb
          mkdir -p dist
          # Check src/target/debian/ (cargo-deb output)
          if ls src/target/debian/*.deb 1> /dev/null 2>&1; then
            cp src/target/debian/*.deb dist/
          fi
          # Check src/ root (yazi build.sh output)
          if ls src/*.deb 1> /dev/null 2>&1; then
            cp src/*.deb dist/
          fi
          
      - name: Package custom build to .deb
        if: matrix.type == 'custom' && !cancelled()
        run: |
          # If no .deb found, create one from built binaries
          if [ ! -f dist/*.deb ]; then
            echo "No .deb found, creating package from built binaries..."
            PKG_NAME="${{ matrix.name }}"
            VERSION="${{ matrix.version }}"
            DEB_VER="${VERSION#v}"
            ARCH="amd64"
            
            mkdir -p pkg/DEBIAN
            
            # Parse install mappings from matrix
            echo '${{ toJson(matrix.install) }}' > install_map.json
            jq -r 'to_entries[] | "\(.key) \(.value)"' install_map.json | while read -r SRC DST;
            do
               if [[ -f "src/$SRC" ]]; then
                  REAL_SRC="src/$SRC"
               elif [[ -f "$SRC" ]]; then
                  REAL_SRC="$SRC"
               else
                  echo "Warning: Source file $SRC not found"
                  continue
               fi
               
               DEST_DIR="pkg$(dirname "$DST")"
               mkdir -p "$DEST_DIR"
               cp "$REAL_SRC" "pkg$DST"
               if [[ "$DST" == */bin/* ]] || [[ "$DST" == *completions* ]]; then
                  chmod 755 "pkg$DST"
               else
                  chmod 644 "pkg$DST"
               fi
            done
            
            # Parse control fields
            MAINTAINER=$(echo '${{ toJson(matrix.control) }}' | jq -r '.maintainer // "KivotOS <kivotos@example.com>"')
            SECTION=$(echo '${{ toJson(matrix.control) }}' | jq -r '.section // "utils"')
            PRIORITY=$(echo '${{ toJson(matrix.control) }}' | jq -r '.priority // "optional"')
            HOMEPAGE=$(echo '${{ toJson(matrix.control) }}' | jq -r '.homepage // ""')
            
            CONTROL="Package: $PKG_NAME\n"
            CONTROL+="Version: $DEB_VER\n"
            CONTROL+="Architecture: $ARCH\n"
            CONTROL+="Maintainer: $MAINTAINER\n"
            CONTROL+="Description: ${{ matrix.description }}\n"
            CONTROL+="Priority: $PRIORITY\n"
            CONTROL+="Section: $SECTION\n"
            if [ -n "$HOMEPAGE" ]; then
              CONTROL+="Homepage: $HOMEPAGE\n"
            fi
            echo -e "$CONTROL" > pkg/DEBIAN/control
            
            mkdir -p dist
            dpkg-deb --build pkg "dist/${PKG_NAME}_${DEB_VER}_${ARCH}.deb"
          fi
          
      - uses: actions/upload-artifact@v4
        with:
          name: deb-${{ matrix.name }}
          path: dist/*.deb

  publish:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: deb-*
          path: all-debs
          merge-multiple: true
          
      - name: Setup Aptly
        run: sudo apt-get install -y aptly
        
      - name: Configure GPG
        run: |
          mkdir -p ~/.gnupg && chmod 700 ~/.gnupg
          printf 'pinentry-mode loopback\nbatch\n' > ~/.gnupg/gpg.conf
          printf 'allow-loopback-pinentry\n' > ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent || true

      - name: Import GPG Key
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
        run: |
          echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
          
      - name: Publish Repo
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          # Create aptly config
          mkdir -p ~/.aptly public
          cat > ~/.aptly.conf <<'JSON'
          {
            "rootDir": ".aptly",
            "downloadConcurrency": 4,
            "FileSystemPublishEndpoints": {
              "public": {
                "rootDir": "./public",
                "linkMethod": "copy"
              }
            }
          }
          JSON
          
          # Initialize Repo
          aptly repo create -distribution=trixie -component=main kivotos
          
          # Add packages
          find all-debs -name "*.deb" -exec aptly repo add kivotos {} +
          
          # Get Key ID (first secret key)
          KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep sec | awk '{print $2}' | cut -d/ -f2 | head -n1)
          
          # Publish to filesystem
          aptly publish repo \
            -architectures=amd64 \
            -gpg-key="$KEY_ID" \
            -passphrase="$GPG_PASSPHRASE" \
            kivotos \
            filesystem:public:
            
          # Add public key
          gpg --export --armor "$KEY_ID" > public/pubkey.gpg
          
          # Generate directory index HTML for browsing
          echo "Generating directory indexes..."
          generate_index() {
            local dir=$1
            pushd "$dir" > /dev/null
            local title="Index of ${dir#public}"
            {
              echo "<!DOCTYPE html><html><head><title>$title</title><style>"
              echo "body{font-family:monospace;background:#fff;color:#000;margin:2em;}"
              echo "hr{border:0;border-top:1px solid #ccc;}"
              echo "a{text-decoration:none;color:#00e;}"
              echo "a:hover{text-decoration:underline;}"
              echo "</style></head><body>"
              echo "<h1>$title</h1><hr><pre>"
              echo "<a href='../'>../</a>"
              ls -1p | grep -v "index.html" | while read -r line; do
                local mtime=$(stat -c '%y' "$line" 2>/dev/null | cut -d'.' -f1 | tr ' ' '_' || echo "-$(date '+%Y-%m-%d_%H:%M')")
                local size=$(du -sh "$line" 2>/dev/null | cut -f1 || echo "-")
                printf "<a href='%s'>%-50s</a> %20s %10s\\n" "$line" "$line" "$mtime" "$size"
              done
              echo "</pre><hr></body></html>"
            } > index.html
            popd > /dev/null
          }
          export -f generate_index
          find public -type d -exec bash -c 'generate_index "$0"' {} \;
          
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          force_orphan: true
