name: apt-packages
on:
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - "packages.json"
      - ".github/workflows/apt-packages.yml"
  schedule:
    - cron: "0 3 1 * *"

permissions:
  contents: write
  packages: write

concurrency:
  group: apt-publish
  cancel-in-progress: false

env:
  COMPONENT: main

jobs:
  matrix:
    runs-on: ubuntu-latest
    outputs:
      packages: ${{ steps.read.outputs.packages }}
      distros: ${{ steps.read.outputs.distros }}
    steps:
      - uses: actions/checkout@v4
      - id: read
        run: |
          sudo apt-get update
          sudo apt-get install -y jq
          set -euo pipefail
          if [ ! -f packages.json ]; then
            echo '{"distros":["trixie"],"packages":[]}' > packages.json
          fi
          echo "packages=$(jq -c '.packages' packages.json)" >> "$GITHUB_OUTPUT"
          echo "distros=$(jq -r '.distros|join(\" \")' packages.json)" >> "$GITHUB_OUTPUT"

  build:
    name: build ${{ matrix.name }}
    needs: matrix
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.matrix.outputs.packages) }}
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl git dpkg-dev build-essential cmake pkg-config
          if [ "${{ matrix.type }}" = "cargo" ]; then
            sudo apt-get install -y rustc cargo
            cargo install cargo-deb --locked
          fi

      - name: Build or Fetch Package
        shell: bash
        env:
          CRATES: ${{ toJson(matrix.crates) }}
          SRC: ${{ matrix.source }}
          REPO: ${{ matrix.repo }}
          TYPE: ${{ matrix.type }}
        run: |
          set -euo pipefail
          ART="${GITHUB_WORKSPACE}/artifacts"
          mkdir -p "$ART"

          # === T·∫°o URL clone d·ª±a v√†o source ===
          CLONE_URL="https://${SRC}/${REPO}"

          echo "üîó Clone URL: $CLONE_URL"
          echo "üì¶ Package type: ${TYPE}"

          # === T·ª± ƒë·ªông l·∫•y phi√™n b·∫£n m·ªõi nh·∫•t ===
          echo "üîç Detecting latest version..."
          case "${SRC}" in
            github.com)
              VER=$(curl -fsSL "https://api.github.com/repos/${REPO}/releases/latest" | jq -r .tag_name | sed 's/^v//')
              ;;
            codeberg.org)
              # Codeberg (Gitea) API l·∫•y release ƒë·∫ßu ti√™n
              VER=$(curl -fsSL "https://codeberg.org/api/v1/repos/${REPO}/releases" | jq -r '.[0].tag_name' | sed 's/^v//')
              ;;
            *) VER="" ;;
          esac

          # Fallback n·∫øu kh√¥ng l·∫•y ƒë∆∞·ª£c qua API
          if [ -z "$VER" ] || [ "$VER" == "null" ]; then
             VER="0.0.0+git$(date -u +%Y%m%d)"
             echo "‚ö†Ô∏è Could not detect version from API, using fallback: $VER"
          else
             echo "‚úÖ Detected version: $VER"
          fi

          case "${TYPE}" in
            cargo)
              git clone --depth=1 "$CLONE_URL" src
              pushd src
              
              if [ -f Cargo.toml ]; then
                if cargo deb --help >/dev/null 2>&1; then
                  if [ "${CRATES}" != "null" ]; then
                    echo "$CRATES" | jq -r '.[]' | while read -r C; do
                      cargo deb -p "$C" --locked
                    done
                  else
                    cargo deb --locked
                  fi
                  mv target/debian/*.deb "$ART"
                else
                  cargo build --release --locked
                  install -Dm755 target/release/* "$ART/"
                fi
              else
                echo "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y Cargo.toml trong repo $REPO"
              fi
              popd
              ;;

            make)
              git clone --depth=1 "$CLONE_URL" src
              pushd src
              NAME="${{ matrix.name }}"
              BINARY="${{ matrix.binary }}"
              DESC="${{ matrix.description }}"; : "${DESC:=Package built by KivotOS CI}"
              
              make
              mkdir -p pkg/DEBIAN pkg/usr/bin "pkg/usr/share/doc/${NAME}"
              install -Dm755 "$BINARY" "pkg/usr/bin/${NAME}" || install -Dm755 "${NAME}" "pkg/usr/bin/${NAME}"
              [ -f README.md ] && install -Dm644 README.md "pkg/usr/share/doc/${NAME}/README.md" || true
              printf '%s\n' \
                "Package: ${NAME}" \
                "Version: ${VER}-1" \
                "Section: utils" \
                "Priority: optional" \
                "Architecture: amd64" \
                "Maintainer: KivotOS <maintainers@kivotos.local>" \
                "Homepage: $CLONE_URL" \
                "Description: ${DESC}" > pkg/DEBIAN/control
              dpkg-deb -Zxz --uniform-compression --build pkg "${NAME}_${VER}-1_amd64.deb"
              mv "${NAME}_${VER}-1_amd64.deb" "$ART"
              popd
              ;;

            mirror)
              echo "üîç Fetching mirror from ${SRC}"
              API="https://api.${SRC}/repos/${REPO}/releases/latest"
              curl -fsSL "$API" | jq -r '.assets[] | .browser_download_url' \
                | grep -E "${{ matrix.pattern }}" \
                | while read -r URL; do FN=$(basename "$URL"); curl -L "$URL" -o "$ART/$FN"; done
              ;;

            custom)
              echo "üìú Running repo's build script with version: $VER"
              git clone --depth=1 "$CLONE_URL" src
              pushd src
              
              # Export VER ƒë·ªÉ script build c·ªßa h·ªç c√≥ th·ªÉ l·∫•y (n·∫øu h·ªç code script nh·∫≠n env)
              export APP_VERSION="$VER"
              
              # Extract script path and arguments
              SCRIPT_CMD="${{ matrix.script }}"
              SCRIPT_PATH=$(echo "$SCRIPT_CMD" | awk '{print $1}')
              SCRIPT_ARGS=$(echo "$SCRIPT_CMD" | cut -d' ' -f2-)
              
              chmod +x "$SCRIPT_PATH"
              ./$SCRIPT_PATH $SCRIPT_ARGS
              
              # Find and move generated .deb files
              find . -name "*.deb" -exec mv {} "$ART/" \;
              
              popd
              ;;

            script)
              echo "üìú Running local build script: ${{ matrix.script }}"
              chmod +x "${GITHUB_WORKSPACE}/${{ matrix.script }}"
              "${GITHUB_WORKSPACE}/${{ matrix.script }}"
              ;;

            *) echo "Unknown type: ${TYPE}"; exit 1;;
          esac

          echo "‚úÖ Build complete for ${{ matrix.name }}"
          ls -lh "$ART"

      - uses: actions/upload-artifact@v4
        with:
          name: debs-${{ matrix.name }}
          path: artifacts/*.deb
          retention-days: 1

  publish:
    name: publish to apt
    needs: [matrix, build]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install deps
        run: |
          sudo apt-get update 
          sudo apt-get install -y aptly
      - name: Download all debs
        uses: actions/download-artifact@v4
        with:
          pattern: debs-*
          path: all-artifacts
      - name: Cache aptly DB
        uses: actions/cache@v4
        with:
          path: .aptly
          key: aptly-db-v1
          restore-keys: |
            aptly-db-
      - name: Configure GPG
        run: |
          mkdir -p ~/.gnupg && chmod 700 ~/.gnupg
          printf 'pinentry-mode loopback\nbatch\n' > ~/.gnupg/gpg.conf
          printf 'allow-loopback-pinentry\n' > ~/.gnupg/gpg-agent.conf
          gpgconf --kill gpg-agent || true

      - name: Publish to APT
        env:
          DISTROS: ${{ needs.matrix.outputs.distros }}
          COMPONENT: ${{ env.COMPONENT }}
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          DISTROS_RAW="${{ needs.matrix.outputs.distros }}"
          if [ -z "${DISTROS_RAW:-}" ]; then
            echo "WARN: DISTROS empty, defaulting to 'trixie'"
            DISTROS="trixie"
          else
            DISTROS="$DISTROS_RAW"
          fi
          echo "DISTROS=${DISTROS}"
          # Chu·∫©n b·ªã th∆∞ m·ª•c xu·∫•t d·ªØ li·ªáu
          mkdir -p repo-public
          cat > ~/.aptly.conf <<'JSON'
          {
            "rootDir": ".aptly",
            "downloadConcurrency": 4,
            "FileSystemPublishEndpoints": {
              "root": {
                "rootDir": "./repo-public",
                "linkMethod": "copy"
              }
            }
          }
          JSON

          echo "$GPG_PRIVATE_KEY" | gpg --batch --yes --import
          KEYID=$(gpg --list-keys --with-colons | awk -F: '/^pub/{print $5; exit}')
          if [ -z "${KEYID:-}" ]; then
            echo "ERROR: GPG KEYID empty. Check GPG_PRIVATE_KEY secret."
            exit 1
          fi
          echo "Using GPG KEYID: $KEYID"

          REPO_NAME="kivotos"
          aptly repo create -component="$COMPONENT" "$REPO_NAME" || true

          # Th√™m c√°c g√≥i m·ªõi v√†o local repo
          find all-artifacts -name "*.deb" -exec aptly repo add -force-replace "$REPO_NAME" {} +

          for distro in $DISTROS; do
            echo "Checking publication for distro: $distro"
            # Ki·ªÉm tra xem distro ƒë√£ ƒë∆∞·ª£c update/publish ch∆∞a
            if aptly publish show "$distro" filesystem:root: >/dev/null 2>&1; then
              echo "Updating existing publication..."
              aptly publish update \
                -gpg-key="$KEYID" \
                -passphrase="$GPG_PASSPHRASE" \
                "$distro" filesystem:root:
            else
              echo "Creating new publication..."
              aptly publish repo \
                -distribution="$distro" \
                -architectures=amd64 \
                -gpg-key="$KEYID" \
                -passphrase="$GPG_PASSPHRASE" \
                "$REPO_NAME" filesystem:root:
            fi
          done

          # Xu·∫•t public key
          gpg --armor --export "$KEYID" > repo-public/pubkey.gpg

          # === T·∫°o giao di·ªán duy·ªát file (Directory Index) gi·ªëng Debian Mirror ===
          echo "üåê Generating directory indexes..."
          generate_index() {
            local dir=$1
            pushd "$dir" > /dev/null
            local title="Index of /${dir#repo-public/}"
            {
              echo "<html><head><title>$title</title><style>body{font-family:monospace;background:#fff;color:#000;}hr{border:0;border-top:1px solid #ccc;}a{text-decoration:none;color:#00e;}a:hover{text-decoration:underline;}</style></head><body>"
              echo "<h1>$title</h1><hr><pre><a href='../'>../</a>"
              ls -1p | grep -v "index.html" | while read -r line; do
                local mtime=$(date -r "$line" "+%d-%b-%Y %H:%M")
                local size=$(du -sh "$line" | cut -f1)
                printf "%-50s %20s %10s\n" "<a href='$line'>$line</a>" "$mtime" "$size"
              done
              echo "</pre><hr></body></html>"
            } > index.html
            popd > /dev/null
          }
          export -f generate_index
          find repo-public -type d -exec bash -c 'generate_index "$0"' {} \;
      - name: Generate timestamp for commit
        id: timestamp
        run: |
          echo "date=$(date -u +%Y-%m-%d)" >> $GITHUB_OUTPUT
          echo "datetime=$(date -u '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_OUTPUT
      - name: Deploy to GitHub Pages üöÄ
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./repo-public
          publish_branch: gh-pages
          force_orphan: false # Gi·ªØ l·∫°i l·ªãch s·ª≠ c√°c g√≥i c≈©
          user_name: "github-actions[bot]"
          user_email: "github-actions[bot]@users.noreply.github.com"
          commit_message: "üöÄ Update APT repository [${{ steps.timestamp.outputs.datetime }}]"
